### TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。

![TCP](img\TCP.png)

三次握手：

1、客户端向服务端发起请求，报文中会包含SYN=1和序列号SEQ=X，客户端进入SYN_SEND状态

2、服务端接受到报文后响应客户端，报文中包含SYN=1、ACK=1、ACK=X+1、SEQ=Y，服务端进入SYN_RCVD状态

3、客户端接收到服务端的响应，向服务端发送报文ACK=1、ACK=Y+1、SEQ=X+1，客户端进入ESTAB-LISHED状态，服务端接受到后也进入ESTAB-LISHED状态

至此连接就建立完毕了

四次挥手：

1、客户端向服务端发送报文，FIN=1、SEQ=N，客户端进入FIN_WAIT_1状态

2、服务端接受到向客户端发送确认报文，ACK=1、SEQ=M、ACK=N+1，服务端进入CLOSED_WAIT状态，此时服务端还可以向客户端发送数据，客户端接收到确认信息进入FIN_WAIT_2状态

3、服务端向客户端发送报文，FIN=1、ACK=1、SEQ=K、ACK=N+1，服务端进入LAST_ACK状态

4、客户端接受到报文后，发送ACK=1、SEQ=N+1、ACK=K+1，客户端进入TIME_WAIT状态，服务端接受到报文后进入CLOSED状态

客户端在TIME_WAIT状态下会持续2MSL，如果没有接受到服务端的信息就自动进入CLOSED状态

需要四次挥手是因为客户端在请求连接的时候，服务端给的响应中包含了SYN同步信号和ACK确认信号，而在关闭连接的时候，服务端在接受的FIN报文后并不会直接关闭连接，可能数据还没有传输完，只能先回复客户端一个ACK报文，待数据全部传送完再发送FIN报文，所以不能一起发送，需要四次挥手

不能将三次握手改为两次握手，三次挥手主要是为了让双方协商序列号，且告知对方已经准备好数据传输了，如果改为两次握手，在服务端发送响应后，可能因为网络因素响应报文丢失，但服务端已经进入数据传输状态了，客户端迟迟收不到响应，就会认为连接未建立，这时无论服务端发送过来的数据就会全部丢弃，而服务端由于收不到客户端对于数据的确认报文就会重复发送，导致死锁

### TIME_WAIT和CLOSE_WAIT的区别。

time_wait状态是为了重复可能丢失的ack报文，close_wait状态是对方已经不会传输数据过来了，我方还能继续传输数据

time_wait是主动关闭，close_wait是被动关闭

### TCP/IP如何保证可靠性，说说TCP头的结构。

使用序号，对收到的报文进行排序以及检测重复性；使用校验和，检测报文段的错误；使用确认和计时器来检测和纠正丢包和延时

TCP头部正常情况下有20个字节，包含16位的源端口、16位的目标端口、32位的序列号、32位的确认号、4位的首部长度（单位是字也就是32位）、16位的窗口大小（单位是字节）、16位的校验和、16位的紧急指针以及8个状态位和4个保留位

### http1.0和http1.1有什么区别。

1.0是无状态和无连接的，也就是说，请求一次，就得创建一个tcp连接，服务端响应后，就关闭这个连接。

无状态可以用session和cookie解决，但是无法解决tcp连接复用的问题，创建和释放tcp连接又比较费时；还会有队头阻塞的问题，1.0规定下一个请求必须是在上一个响应接收到后才能发出，如果一直接收不到就阻塞

1.1支持长连接，增加了一个connection字段，值为keep-alive可以保持连接不断，避免多次请求重复创建tcp连接，如果想关闭就将connection的值改为closed，同时服务端关闭连接；

支持管道化，就是说，客户端并行发起多个请求，但并不是真正意义上的并行，服务端必须按照请求的时间顺序依次返回结果，保证客户端能区分响应内容，但是如果第一个请求比较耗时，后面的请求必须等待响应传输完毕才能开始传输，所以现在很多浏览器就不支持，但是像谷歌浏览器能做到真正意义上的并行是因为同时打开了多个tcp连接（对同域下并行下载资源会有6~8个的限制）

除此之外，1.1还有增强了缓存的功能，新增了cache-control字段，1.0的expires只能指定一个过期时间而且还是依赖于用户电脑的时间，cache-control：max-age=10000可以指定缓存的生存倒计时秒数，这样就不依赖用户电脑的时间了

### 说说你知道的几种HTTP响应码，比如200, 302, 404。

1xx：信息

2xx：成功

> 200：OK

3xx：重定向

> 302：页面重定向到另一个页面
>
> 304：可以从缓存中拿到响应

4xx：客户端错误

> 404：服务端无法找到被请求的页面
>
> 405：请求方法错误

5xx：服务端错误

### 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。

1. 域名解析
2. 发起TCP三次握手
3. 建立TCP连接后发起http请求
4. 服务端响应http请求
5. 浏览器拿到html页面代码
6. 浏览器解析html页面代码，并请求html中的资源（css、js、img）
7. 浏览器对页面进行渲染呈现给客户

### 如何避免浏览器缓存。

cache-control:no-cache/cache-control:max-age=0无法被缓存

post请求无法被缓存

### 如何理解HTTP协议的无状态性。

http每次请求都是独立的，对客户端的每次请求返回响应后，不会记录任何信息，如果后续处理需要前面的信息就必须重传

### 简述Http请求get和post的区别以及数据包格式。

get请求和post请求本质上没什么区别都使用tcp协议，只是http协议规定，产生了一些区别：

get在浏览器退回时是无害的，而post在回退时会重新提交；get请求会被浏览器主动缓存，而post请求不会；get请求的参数直接写在url中且长度最大为2K，post请求参数写在body长度没有限制

最大区别就是：get请求产生一个数据包，而post请求产生两个数据包。浏览器会将get请求的header和data一起发送出去，服务端响应200；对于post请求，浏览器先发送header，服务端返回100 contiune，浏览器再将data发送出去，服务端响应200

### HTTP有哪些method

get、post、put、delete、options、head、connect、trace、patch

### 简述HTTP请求的报文格式。

请求格式

> 请求方法 url 协议版本
>
> header参数
>
> 空行
>
> body参数

响应格式：

> 协议版本 状态码 状态码描述
>
> header参数
>
> 空行
>
> body参数

### HTTP的长连接是什么意思。

http的长连接和短连接是针对tcp而言的，短连接就是发送一次请求收到响应后就关闭tcp连接，长连接是在进行完一次请求后不关闭连接，后续请求继续使用这个连接

### HTTPS的加密方式是什么，讲讲整个加密解密流程。

加密方法是tls/ssl，https采用对称加密、非对称加密、hash算法实现

1. tcp建立连接
2. 客户端发送hello报文，包含支持的ssl版本、加密组件等
3. 服务端发送hello报文，确定ssl版本，加密组件、以及数字证书
4. 客户端验证数字证书的有效性
5. 客户端用服务端的公钥加密随机对称秘钥并发送
6. 服务端用私钥解密得到随机对称秘钥
7. 至此客户端和服务端就协商好对称秘钥，之后的就是将http报文加密传输

### 什么是TCP粘包，拆包。解决方式是什么。

tcp为了提高性能，发送端会将数据放入缓冲区，缓冲区满了才会将数据发送出去，同样接收端也会有缓冲区这样的机制，但是如果，数据包的大小小于缓冲区的大小导致有两个数据包同时放入缓冲区一起发送，就是粘包；如果数据包的大小大于缓冲区的大小一个数据包分成多次发送就是拆包现象

### Http和https的三次握手有什么区别。

### 什么是分块传送。

### Session和cookie的区别。


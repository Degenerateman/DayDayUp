### 多线程的几种实现方式，什么是线程安全。

实现runnable接口、继承Thread类、实现Callable接口。

当多个线程同时访问一个共享数据时，结果与预期的一样那就是线程安全的，反之就是线程不安全的

### volatile的原理，作用，能代替锁么。

volatile变量可以保证在每次读取他的时候都从主内存上读取，在赋值操作之后，都会立刻将值刷新到主内存上，以上说明volatile变量可以保证可见性，他还有一个作用就是禁止重排序（java编译器和处理器为了提高程序的性能会对代码进行重排序）原理就是在写操作之前插入StoreStoreBarrier，写操作之后插入StoreLoadBarrier，读操作之后插入LoadLoadBarrier和LoadStoreBarrier。

不能代替锁，因为锁保证的不旦旦是可见性，还保证了原子性

> StoreStoreBarrier：禁止前面的写操作与后面的写操作重排序
>
> StoreLoadBarrier：禁止前面的写操作与后面的volatile读操作重排序
>
> LoadLoadBarrier：禁止前面的读操作与后面的读操作重排序
>
> LoadStoreBarrier：禁止前面的读操作与后面的写操作重排序

### 画一个线程的生命周期状态图。

![image-20200411160417980](img\image-20200411160417980.png)



### sleep和wait的区别。

sleep是让线程处于休眠状态，wait让线程处于等待状态

sleep是Thread的静态方法，wait是Object的实例方法

sleep并不会释放锁，并在指定的时间自动唤醒，而wait会直接释放锁

### sleep和sleep(0)的区别。

sleep是让线程挂起处于等待状态，待到指定时间后将自动唤醒，这是线程就处于就绪态，重新竞争cpu，sleep(0)并不会将线程挂起0毫秒处于等待状态，而是直接放弃现有的cpu资源，让线程处于就绪状态，重新竞争cpu

### Lock与Synchronized的区别 。

lock和synchronized都保证了原子性和可见性，区别就是synchronized是C++实现的，而且竞争不到锁的时候，只能一直等待不能人为的干预，比如中断或者设置超时时间，还有就是锁是互斥锁；Lock是由java实现的采用的是locksupport使线程进入等待状态，有两个常用的实现就是ReentrantLock和ReadWriteLock，添加了定时锁和可中断锁的功能

### synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。

synchronized底层是使用monitorenter和monitorexit实现的，在对对象进行加锁时，会先对对象头中锁标记进行进行判断，如果是无锁状态，就再判断下偏向锁的状态，如果没有线程持有偏向锁，那就将当前线程的ID写入对象头，并将偏向锁的状态置为1，执行同步代码块；如果当前线程正好持有该对象的偏向锁，那就是执行同步代码块，如果别的线程持有偏向锁，那就用CAS的方式修改对象头中的线程ID，修改成功就执行代码块，修改失败就暂停原持有偏向锁的线程，判断对象是否处于被锁定状态，如果没有，那就修改对象头中的线程ID，如果有那就将锁升级为轻量级锁，

java对象中包含对象头就是markword，markword包含了一个monitor，monitor中有个waitset和entrylist和cxq

synchronized可以用在实例方法上、静态方法上、代码块上。用在实例方法上锁的对象是就是当前对象，用在静态方法上锁的对象是当前类的Class对象，一起运行的话不会有影响毕竟锁的对象不是同一个。

重排序：java编译器和处理器会对代码进行优化，重新对代码进行排序，以提高代码的执行效率

自旋锁：就是在进行竞争锁的时候，如果没有竞争到，不把线程挂起而是循环执行一个空循环，如果进行了一定次数循环后，获得锁就执行代码块，如果还是没有获得锁再将线程挂起

可重入锁：就是同一个线程在获取到锁后，如果再次获取同一个锁，也是可以获取到的。

公平锁：就是在多个线程等待锁释放时，一旦锁释放，那么第一个等待锁的线程就会获取到锁，换言之就是，先来的先获得锁

非公平锁：与公平锁相反，获得锁的线程不一定是等待时间最长的线程

乐观锁：就是每次读数据的时候都认为别人不会修改数据，在写数据的时候判断一下此期间数据是否别修改过，可以用版本号等机制。

悲观锁：就很悲观，每次读取数据时都会认为别人会修改数据，所以在获取数据时，必须先对数据进行加锁，别人就无法修改它的数据

重量级锁：synchronized底层是用监视器monitor实现的，他是用的操作系统的mutex lock实现的，操作系统实现线程切换就要将用户态转换为核心态，这个成本非常高，耗时比较长，这也是synchronized效率低的原因。这中依赖mutex lock实现的锁就被称为重量级锁

轻量级锁：轻量级锁是相对于重量级锁来说的，也不能代替重量级锁，本意是指，在没有多线程同时竞争锁的情况下，减少重量级锁产生的性能消耗，但是如果同一时间多个线程竞争一个锁，那就会膨胀为重量级锁

偏向锁：偏向锁是在没有多线程竞争锁的情况下，减少轻量级锁的性能消耗所产生的，因为轻量级锁依赖于CAS指令，而偏向锁只需要在置换线程ID时才会执行一次CAS指令

### 用过哪些原子类，他们的原理是什么。

AtomicInteger、AtomicLong、AtomicReference、AtomicBoolean；原理是采用CAS实现的

### JUC下研究过哪些并发工具，讲讲原理。

CountDownLatch：内部类继承了AQS实现了共享锁，常用的方法就是await和countDown，在new对象的时候，传入一个值n，这个值表示共享锁的个数。在new对象的时候，就默认加了n次共享锁，之后每次调用countDown都会释放一个共享锁，调用await方法的逻辑就是获取一个共享锁，有个条件是在共享锁全部释放完毕才能获取到

CyclicBarrier：常用方法是await方法，在调用它的时候，会先用reentrantLock获取锁。然后将count减1，判断count是否为0如果不为0就用condition将线程等待，否则重置count并将condition上的线程唤醒

Samephore：其实就是一个共享锁，只不过是指定了共享锁的数量

### 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。

coreSize表示核心线程的数量，maxSize表示最大线程的数量，workQueue表示任务队列

newCache它的核心线程数为0，最大线程数为integer.max，newFixed的核心线程数和最大线程数是一样的，都是指定。

在将任务添加到线程池的时候，会先判断当前正在执行的线程数，如果小于核心线程数，就会新增一个线程去执行任务；如果大于就尝试将任务插入到任务队列中，如果插入成功，还会再次判断是否需要新增一个线程，因为有可能刚才正在工作的线程已经挂掉了；如果插入队列失败，就判断正在执行线程数是否小于最大线程数，如果小于新增一个线程执行任务，否则执行拒绝策略

线程在执行完当前的任务，并不会马上停止，而是去看看工作队列中是否还有未执行的任务，如果没有线程才会停止

### 线程池的关闭方式有几种，各自的区别是什么。

假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到

spring的controller是单例还是多例，怎么保证并发的安全。
用三个线程按顺序循环打印abc三个字母，比如abcabcabc。
ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。

如果让你实现一个并发安全的链表，你会怎么做。
有哪些无锁数据结构，他们实现的原理是什么。
讲讲java同步机制的wait和notify。
CAS机制是什么，如何解决ABA问题。
多线程如果线程挂住了怎么办。
countdownlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch.await方法和是怎么实现的)。
对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同。
简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
导致线程死锁的原因？怎么解除线程死锁。
非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。
用过读写锁吗，原理是什么，一般在什么场景下用。
开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。
延迟队列的实现方式，delayQueue和时间轮算法的异同。
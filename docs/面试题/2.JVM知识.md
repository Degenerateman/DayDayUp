### 什么情况下会发生栈内存溢出。

递归层数过多，原因是栈中容不下更多的栈帧

方法体内本地变量过多，原因是栈帧过大

### JVM的内存结构，Eden和Survivor比例。

jvm主要包括堆、虚拟机栈、本地方法栈、方法区、程序计数器

Eden与survivor比例默认是8:1:1

PS：-XX:SurvivorRatio=8 表示eden和survivor区的比例为8:1

-XX:NewRatio=4 表示新生代与老年代的比例为1:4

### JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

新生代中存放的对象是新生成或者是年龄较小的对象，而老年代存放的对象主要是年龄较大的对象或者说是不容易死掉的对象，持久代存放的是class和常量池，一般情况下，也不会有垃圾，系统里面产生的对象大都是用一次就不用了或者说是朝生夕死，如果不分代，每次GC时都需要判断所有的对象是否存活，但是有些对象基本上是不会死的，每次都去检查浪费时间，分代后，不容易死的对象放在老年代，新生成的放在新生代，这样每次内存不够用时，就可以先去回收新生代，毕竟新生代的对象存活概率比较低，回收的效果会更好，这样就避免了整个堆去扫描了，提高GC效率

### JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。

### 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

Serial：

> 是新生代的单线程垃圾回收器，采用的算法是复制算法，每次进行垃圾回收时，会让所有的工作线程跑到最近的安全点，然后暂停，启动一个垃圾回收线程去清理垃圾，优点是简单高效，因为是它是单线程的所以也没有线程切换的开销，缺点就是暂停时间可能会很长

ParNew：

> 是新生代的多线程垃圾回收器，工作流程与Serial大致一样，唯一的区别就是Serial只会启动一个垃圾回收线程，而ParNew会启动多条垃圾回收线程同时清理垃圾，优点就是在多CPU的环境下，垃圾回收的速率要比Serial高，单CPU的情况下就不如Serial了，毕竟有线程切换的开销。缺点也是和Serial一样

Parallel Scavenge：

> 是新生代的多线程垃圾回收器。工作流程与ParNew一样，但是他的关注点是吞吐量，目标也是达到一个可控制的吞吐量，可以通过-XX:MaxGCPauseMillis设置最大的停顿时间或者-XX:GCTimeRatio参数设置吞吐量的大小

Serial Old：

> 是老年代的单线程垃圾回收器，工作流程与Serial一样也会暂停所有工作线程，用的算法是标记整理法。

Parallel Old：

> 是老年代的多线程垃圾回收器，采用的是标记整理算法。也是需要暂停所有线程主要是配合Parallel scavenge使用的。

CMS：

> 是老年代垃圾回收器，采用的算法是标记清除法。主要工作流程：初始标记，暂停所有线程，对GCRoot直接关联的对象进行标记；并发标记，就是根据GCRoot对所有对象进行可达性分析，标记存活的对象，这一过程可与工作线程并发执行；重新标记，这个过程主要是修正在并发标记期间，因用户程序产生的标记改变，这个过程也是需要暂停所有线程的，耗时会比初始标记时间长但要比并发标记要短很多；并发清除，这个过程就是清除的垃圾，这个过程也是可以与工作线程并发执行的。优点就是停顿时间短，缺点就是占用的CPU资源比较多，大概会占到25%；无法清除浮动垃圾，因为并发标记和并发清除都是和工作线程并发执行的，所以在此期间产生的新垃圾就不会清除掉，而且还需要给工作线程预留一部分空间，毕竟工作线程在执行过程难免会产生新的对象；由于采用的是标记清除法，就会有空间碎片的产生，但是CMS也提供了相应的参数，可以在垃圾回收完进行整理。

G1：

> G1垃圾回收器将整个划分为多个区域，虽然保留了新生代和老年代的概念，但是也不在是物理隔离了，而且每个区域都会有一个rememberd set用于记录该区域内对象引用其他区域对象的区域。主要流程：初始标记，此过程与CMS一样，都是标记GCRoot能直接关联的对象，也是需要暂停所有线程的；并发标记，也与CMS一样，与工作线程并发，根据GCRoot对堆中的对象进行可达性分析找出存活的对象；最终标记，修正在并发标记阶段导致标记发生变动的记录，虚拟机会将这些记录记录到Rememberd Set Log中，在最终标记时，将其融合到Rememberd Set中，这个阶段是暂停所有线程的，但是可以并行执行；筛选回收，虚拟机会根据各个区域的回收价值和成本以及用户期望的GC停顿时间指定回收计划，进行回收。

### 垃圾回收算法的实现原理。

标记清除法：就是标记出需要回收的对象，然后将其清除掉，缺点是标记和清除的效率并不高，而且会产生空间碎片

标记整理法：先标记出存活的对象，将这些对象移动到堆的一端，然后清理其余部分，优点是不会产生空间碎片

复制算法：将内存分为大小相等的两个区域，每次只使用其中的一块，GC的时候，将存活的对象复制到另一块区域，然后整体清除之前的区域。优点是没有空间碎片，缺点就是太浪费空间了

### 当出现了内存溢出，你怎么排错。

### JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。

内存屏障：为了保证执行顺序和可见性的一条CPU指令

重排序：为了提高性能，编译器和处理器会对执行顺序进行重排序

happen-before：操作间执行的顺序关系

> 程序次序规则：一个线程内，前面的代码先行发生与后面的代码
>
> 锁规则：释放锁的操作先行发生与后面对同一个锁的加锁操作
>
> volatile规则：对一个volatile变量的赋值操作先行发生与后面对这个变量的读操作
>
> 线程启动规则：一个线程的启动操作先行发生于这个线程后面的操作
>
> 线程中断规则：调用线程的interrupt方法先行发生于这个线程对中断的处理操作
>
> 线程终止规则：一个线程所有的操作先行发生于对这个线程的终止检测操作
>
> 对象终结规则：一个对象的初始化操作先行发生于这个对象的finalize()方法开始
>
> 传递性规则：如果A先行发生于B，B先行发生于C，那么A先行发生于C

主内存：共享变量存放的区域

工作内存：每个线程copy主内存的本地内存，存储了该线程的读写共享变量的副本

### 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

主要有三种：启动类加载器，加载范围是jre/lib目录下的jar，且是按名称进行加载的，如果自己的jar包放在lib下页不会加载；扩展类加载器，加载范围是jre/lib/ext目录下的jar或者被java.ext.dirs系统变量所指定路径下载的所有类库；应用类加载器，加载范围是用户类路径classpath上所指定的所有类库，这个类加载器也是程序中默认的类加载器。启动类加载器是扩展类加载器的父类加载器，扩展类加载器是应用类加载器的父类加载器。如果要加载一个类，会优先让父类加载器进行加载，如果加载不到才会尝试自己加载

自定义一个类加载器，并重写loadClass方法和findClass方法

### 你们线上应用的JVM参数有哪些。

wrapper.java.additional.1=-server 启用server模式
wrapper.java.additional.8=-XX:MaxNewSize=256m	最大新生代的大小为256M
wrapper.java.additional.9=-XX:MaxPermSize=512m	最大方法区的大小为512M
wrapper.java.additional.11=-XX:+HeapDumpOnOutOfMemoryError 	导出堆内存溢出时的堆信息
wrapper.java.additional.12=-XX:HeapDumpPath=../logs/heapdump.hprof	导出文件路径
wrapper.java.additional.13=-XX:ErrorFile=../logs/hs_err_pid_%p.log	保存错误日志到文件中

### g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。

### 怎么打出线程栈信息。

Thread.currentThread().getStackTrace();

### 请解释如下jvm参数的含义：

-server 表示jvm启用server模式

-Xms512m 堆最小大小为512M

-Xmx512m 堆最大大小为512M

-Xss1024K 栈大小为1024K

-XX:PermSize=256m 方法区的初始大小为256M

-XX:MaxPermSize=512m 方法区最大的大小为512M

-XX:MaxTenuringThreshold=20 对象晋升到老年代的年龄最大值为20

-XX:CMSInitiatingOccupancyFraction=80 指定CMS在对内存占用率达到80%的时候开始GC

-XX:+UseCMSInitiatingOccupancyOnly。只是用于设定回收阈值（上面指定的80）；如果不指定，JVM仅在第一次使用设定的阈值，后续就会自己调整
### Linux系统下你关注过哪些内核参数，说说你知道的。

### Linux下IO模型有几种，各自的含义是什么。

IO操作可以分为数据准备和数据复制两个阶段

> 阻塞IO

线程从发起IO操作一直阻塞到数据操作完成

> 非阻塞IO

线程发起IO操作后立即返回，然后循环检查数据是否准备完毕，数据准备好后，用户进程等待数据复制完成

> 多路复用IO

与阻塞IO类似，不用的是线程是阻塞在select方法上，并且可以有多个线程同时阻塞，由select方法轮询检查所有IO的就绪情况，只要有IO就绪就返回

> 信号驱动IO

线程发起IO操作时，立即返回，等到数据准备好后，通知线程，用户线程向内核发起数据复制处于阻塞状态，类似于回调函数

> 异步IO

线程发起IO操作时，立即返回，内核将数据复制好后通知线程

### epoll和poll有什么区别。

select、poll、epoll都是多路复用IO的机制，一个进程可以监视多个描述符、一旦某个描述符就绪，能够通知程序进行相应的读写操作。但是select、poll、epoll本质都是同步IO，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间

select监视的文件描述符(fd)分3种，writefds、readfds和exceptfds，调用后select函数会阻塞，知道有fd就绪或者超时，函数返回，当select函数返回后，可以遍历fdset，来找到就绪的fd。select几乎所有的平台都支持，跨平台是他的优点，缺点就是单个进程能够监视的fd数量存在最大限制，linux一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是也会造成效率降低

poll不在使用select的参数值传递方式，而是使用pollfd的结构体保函了监视的event和发生的event，与select一样poll返回后需要轮询pollfd来获取就绪的描述符，但是pollfd并没有最大数量的限制（数量大了后性能也会下降）

epoll不同于select/poll需要调用一定的方法后，内核才会所有监视的fd进行扫描，而epoll实现通过epoll_ctl来注册一个fd，一旦某个fd就绪，内核会采用类似回调方法的形式，激活这个fd，当进程调用epoll_wait就会得到通知，不需要遍历fd，而且监视的fd数量不受限制，所支持的fd上限是最大可以打开文件的数据，1G的内存大约是10万左右

### 平时用到哪些Linux命令。

### 用一行命令查看文件的最后五行。

### 用一行命令输出正在运行的java进程。

### 介绍下你理解的操作系统中线程切换过程。

### 进程和线程的区别。

### top 命令之后有哪些内容，有什么作用。

### 线上CPU爆高，请问你如何找到问题所在。
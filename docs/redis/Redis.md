## Redis

### 为啥使用redis

传统的关系型数据库（mysql）已经不能使用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易吧数据库打崩，所以引入缓存中间件，目前常用的有redis和memcached，考虑到他们的优缺点，最后选择Redis

### redis有哪些数据结构

字符串string、字段Hash、列表List、集合Set、有序集合SortedSet

HyperLogLog、Geo、Pub/Sub

还有Redis Module，如：BloomFilter、RedisSearch、Redis-ML

### 如果有大量的key需要设同一时间过期，一般需要注意什么？

如果大量的key过期时间设置的国语集中，到过期时间那个点的时，redis可能会出现短暂的卡顿现象，严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。

### 你使用过Redis分布式锁么，它是怎么回事

先拿setnx来争抢锁，抢到之后，在用expire给锁加一个过期时间防止锁忘记释放

### 如果setnx之后执行expire之前进程意外crash或者要重启维护，那么会怎样

set命令有个非常复杂的参数，可以把setnx和expire合成一条命令执行

### 假设redis里面有1亿和key，其中10W个key是以某个固定的已知的前缀开头的，如果将他们全部找出来？

使用keys指令keyid扫描出指定模式的key列表

### 如果这个redis正在给线上的业务提供服务，那么使用keys指令会有什么问题？

redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，知道指令执行完毕，服务才能恢复，这个时候使用scan指令，scan命令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接使用keys指令长

不过增量式迭代命令也不是没有缺点，举个例子，使用smembers命令可以返回集合键当前包含的所有元素，但是对于scan这类增量式迭代命令来说，因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证

### 使用过redis做异步队列么，你是怎么用的？

一般使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试

### 如果对方追问可不可以不用sleep？

list还有一个指令叫blpop，在没有消息的时候，他会阻塞住知道消息到来

### 如果对方接着追问能不能生产一次消费多次呢？

使用pub/sub主题订阅模式，可以实现1：N的消息队列

### 继续追问pub/sub有没有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列

### 还他妈追问redis如何实现延时队列？

使用sortedset，那时间戳做分数，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理

---

### redis是怎么实现持久化的？服务主从数据怎么交互的？

RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长的时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态

> 理解：把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你在回访一下日志，数据就完整了。不过redis本身的机制是AOF持久化开启且存在AOF文件时，优先加载AOF文件，AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件后，redis启动成功；AOF/RDB文件存在错误时，redis启动失败并打印错误信息

### 如果突然机器断电会怎么样？

取决于AOF日志sync属性的配置，如果不要求性能，在每条写执行时都sync一下磁盘，就不会丢失数据，但是在高性能的要求下每次都sync是不现实的，一般都是使用定时sync，比如1秒1次，这个时候最多就会丢失1s的数据

### RDB的原理是什么？

fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

> 如果能打出AOF和RDB的优缺点更好。

### Pipeline有什么好处，为什么要用pipeline？

可以将多次IO往返的时间缩减为一次，前提是pipeline执行的命令之间没有因果相关性。使用redis-benchmrak进行压测的时候可以发现影响redis和QPS峰值的一个主要因素是pipeline批次指令的数目

### Redis的同步机制了解吗？

redis可以所使用主从同步，从从同步。第一次同步时，主节点做一次bdsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog

### 是否使用过redis集群，集群的高可用是怎么保证的，集群的原理是什么？

redis sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

redis cluster着眼于扩展性，在单个redis内存不足时，使用cluster进行分片存储

---

### 缓存雪崩了解么？

我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，，或者查不到之后去更新的，定时刷新就会有一个问题。比如，所有首页的key失效时间都是12个小时，中午12点的时候刷新的，我零点有个秒杀活动大量的用户涌入，假设当时每秒6000个请求，本来缓存在可以扛住每秒5000个请求，但是缓存当时所有的key都失效了，此时1秒6000个请求全部打到数据库上，数据库就扛不住了，他会报一下警，真实情况可能连DBA都没有反应过来就直接挂了，此时，如果没用什么特别的方案来处理这个故障，DBA很着急，重启数据库，但是数据库立马又被新的流量给打崩了，这就是我理解的缓存雪崩

### 怎么解决缓存雪崩？

在批量往redis存数据的时候，把每个key的失效时间都加上一个随机值就好了，这样可以保证数据不会在同一时间大面积失效

如果是redis是集群部署，将热点数据均匀分布在不同的redis库中也能避免全部失效的问题，不过我在生产环境中操作集群的时候，单核服务都是对应单个redis分片的，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端

或者设置热点数据永不过期，有更新操作直接更新缓存就好了，比如运维更新首页商品，刷新下缓存就完事了

### 那你了解缓存穿透和缓存击穿么，可以说说他们和雪崩的区别么？

缓存穿透是指缓存和数据库中都没有数据，而用户不断发起请求，我们数据库的id都是从1开始自增上去的，如果发起id值为-1的数据或者id特别大不存在的数据。这时的用户可能是攻击者，攻击会导致数据库压力过大，严重就会击垮数据库

至于缓存击穿和缓存雪崩有点像，但是又不一样，缓存雪崩是因为大面积的缓存失效，打崩了数据库；而缓存击穿不同，是指一个key非常热点，在不停的扛住大并发，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破了缓存，直接请求到数据库，就好像在一个完好无损的桶上凿开了一个洞

### 缓存穿透和缓存击穿怎么解决？

缓存穿透，可以加上参数校验，不合法的参数直接return掉，可以将这个key的value写成null存入redis设置一个短一点的失效时间比如30秒。还可以使用redis的布隆过滤器，这个可以快速判断出key在数据库中是否存在，如果不存在直接return就好了

缓存击穿的话，设置热点数据永不过期就好了，或者加上互斥锁。